{
  "version": 3,
  "sources": ["../../../seamless-scroll-polyfill/src/common.ts", "../../../seamless-scroll-polyfill/src/scroll-end-event.ts", "../../../seamless-scroll-polyfill/src/scroll-step.ts", "../../../seamless-scroll-polyfill/src/scroll.ts", "../../../seamless-scroll-polyfill/src/scrollIntoView.ts", "../../../seamless-scroll-polyfill/src/scroll.polyfill.ts", "../../../seamless-scroll-polyfill/src/scrollIntoView.polyfill.ts", "../../../seamless-scroll-polyfill/src/polyfill.ts"],
  "sourcesContent": ["import type { IScrollConfig } from \"./scroll-step.js\";\n\nexport const checkBehavior = (behavior?: string): behavior is undefined | ScrollBehavior => {\n    return behavior === undefined || behavior === \"auto\" || behavior === \"instant\" || behavior === \"smooth\";\n};\n\nexport function elementScrollXY(this: Element, x: number, y: number): void {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n}\n\nexport const failedExecute = (method: string, object: string, reason = \"cannot convert to dictionary.\"): string =>\n    `Failed to execute '${method}' on '${object}': ${reason}`;\n\nexport const failedExecuteInvalidEnumValue = (method: string, object: string, value: string): string =>\n    failedExecute(method, object, `The provided value '${value}' is not a valid enum value of type ScrollBehavior.`);\n\ninterface BackupMethod {\n    <K extends keyof Element>(proto: Element, method: K): Element[K] | undefined;\n    <K extends keyof Element>(proto: Element, method: K, fallback: unknown): Element[K];\n    <K extends keyof Window>(proto: Window, method: K): Window[K] | undefined;\n    <K extends keyof Window>(proto: Window, method: K, fallback: unknown): Window[K];\n}\n\n/* eslint-disable */\nexport const backupMethod: BackupMethod = (proto: any, method: string, fallback?: unknown) => {\n    const backup = `__SEAMLESS.BACKUP$${method}`;\n\n    if (!proto[backup] && proto[method] && !proto[method]?.__isPolyfill) {\n        proto[backup] = proto[method];\n    }\n\n    return proto[backup] || fallback;\n};\n/* eslint-enable */\n\nexport const isObject = (value: unknown): boolean => {\n    const type = typeof value;\n    return value !== null && (type === \"object\" || type === \"function\");\n};\n\nexport const isScrollBehaviorSupported = (config?: IScrollConfig): boolean =>\n    \"scrollBehavior\" in window.document.documentElement.style && config?.forcePolyfill !== true;\n\nexport const markPolyfill = (method: () => void): void => {\n    Object.defineProperty(method, \"__isPolyfill\", { value: true });\n};\n\ntype Prototype = typeof HTMLElement.prototype | typeof SVGElement.prototype | typeof Element.prototype;\n\nexport const modifyPrototypes = <T extends \"scroll\" | \"scrollTo\" | \"scrollBy\" | \"scrollIntoView\">(\n    prop: T,\n    func: Prototype[T],\n): void => {\n    markPolyfill(func);\n    [HTMLElement.prototype, SVGElement.prototype, Element.prototype].forEach((prototype) => {\n        backupMethod(prototype, prop);\n        prototype[prop] = func;\n    });\n};\n\n/**\n * - On Chrome and Firefox, document.scrollingElement will return the <html> element.\n * - Safari, document.scrollingElement will return the <body> element.\n * - On Edge, document.scrollingElement will return the <body> element.\n * - IE11 does not support document.scrollingElement, but you can assume its <html>.\n */\nexport const scrollingElement = (element: Element): Element =>\n    element.ownerDocument.scrollingElement || element.ownerDocument.documentElement;\n", "export function scrollEndEvent(bubbles: boolean): Event {\n    if (typeof Event === \"function\") {\n        return new Event(\"scrollend\", {\n            bubbles,\n            cancelable: false,\n        });\n    }\n\n    const event = document.createEvent(\"Event\");\n    event.initEvent(\"scrollend\", bubbles, false);\n\n    return event;\n}\n", "export interface IScrollConfig {\n    readonly duration?: number;\n    readonly forcePolyfill?: boolean;\n    readonly timingFunc?: (k: number) => number;\n}\n\nexport interface IContext extends IScrollConfig {\n    readonly timeStamp: number;\n    readonly startX: number;\n    readonly startY: number;\n    readonly targetX: number;\n    readonly targetY: number;\n    readonly method: (x: number, y: number) => void;\n    readonly callback: () => void;\n    rafId: number;\n}\n\nconst ease = (k: number) => {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n};\n\n/* eslint-disable */\nexport function now(): number {\n    let fn: () => number;\n    if (window.performance?.now) {\n        fn = () => window.performance.now();\n    } else {\n        fn = () => window.Date.now();\n    }\n\n    // @ts-ignore\n    now = fn;\n    return fn();\n}\n/* eslint-enable */\n\nconst DURATION = 500;\n\nexport const step = (context: IContext): void => {\n    const currentTime = now();\n\n    const elapsed = (currentTime - context.timeStamp) / (context.duration || DURATION);\n    if (elapsed > 1) {\n        context.method(context.targetX, context.targetY);\n        context.callback();\n        return;\n    }\n    const value = (context.timingFunc || ease)(elapsed);\n\n    const currentX = context.startX + (context.targetX - context.startX) * value;\n    const currentY = context.startY + (context.targetY - context.startY) * value;\n\n    context.method(currentX, currentY);\n\n    context.rafId = window.requestAnimationFrame(() => {\n        step(context);\n    });\n};\n", "import {\n    backupMethod,\n    checkBehavior,\n    elementScrollXY,\n    failedExecute,\n    failedExecuteInvalidEnumValue,\n    isObject,\n    scrollingElement,\n} from \"./common.js\";\nimport { scrollEndEvent } from \"./scroll-end-event.js\";\nimport type { IContext, IScrollConfig } from \"./scroll-step.js\";\nimport { now, step } from \"./scroll-step.js\";\n\n// https://drafts.csswg.org/cssom-view/#normalize-non-finite-values\nconst nonFinite = (value: unknown): number => {\n    if (!isFinite(value as number)) {\n        return 0;\n    }\n    return Number(value);\n};\n\nconst isConnected = (node: Node) => {\n    return (\n        node.isConnected ??\n        (!node.ownerDocument ||\n            // eslint-disable-next-line no-bitwise\n            !(node.ownerDocument.compareDocumentPosition(node) & /** DOCUMENT_POSITION_DISCONNECTED */ 1))\n    );\n};\n\nconst scrollWithOptions = (element: Element, options: Readonly<ScrollToOptions>, config?: IScrollConfig): void => {\n    if (!isConnected(element)) {\n        return;\n    }\n\n    const startX = element.scrollLeft;\n    const startY = element.scrollTop;\n\n    const targetX = nonFinite(options.left ?? startX);\n    const targetY = nonFinite(options.top ?? startY);\n\n    if (targetX === startX && targetY === startY) {\n        return;\n    }\n\n    const fallback = backupMethod(HTMLElement.prototype, \"scroll\", elementScrollXY);\n    const method = backupMethod(Object.getPrototypeOf(element) as Element, \"scroll\", fallback).bind(element);\n\n    if (options.behavior !== \"smooth\") {\n        method(targetX, targetY);\n        return;\n    }\n\n    const removeEventListener = () => {\n        window.removeEventListener(\"wheel\", cancelScroll);\n        window.removeEventListener(\"touchmove\", cancelScroll);\n    };\n\n    const callback = () => {\n        removeEventListener();\n        const isDocument = element.nodeType === /** Node.DOCUMENT_NODE */ 9;\n        element.dispatchEvent(scrollEndEvent(isDocument));\n    };\n\n    const context: IContext = {\n        ...config,\n        timeStamp: now(),\n        startX,\n        startY,\n        targetX,\n        targetY,\n        rafId: 0,\n        method,\n        callback,\n    };\n\n    const cancelScroll = () => {\n        window.cancelAnimationFrame(context.rafId);\n        removeEventListener();\n    };\n\n    window.addEventListener(\"wheel\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n    window.addEventListener(\"touchmove\", cancelScroll, {\n        passive: true,\n        once: true,\n    });\n\n    step(context);\n};\n\nconst isWindow = (obj: unknown): obj is Window => (obj as Window).window === obj;\n\ntype ScrollMethod<T extends Element | typeof window> = (\n    target: T,\n    scrollOptions?: ScrollToOptions,\n    config?: IScrollConfig,\n) => void;\n\nconst createScroll =\n    <T extends Element | typeof window>(scrollName: \"scroll\" | \"scrollTo\" | \"scrollBy\"): ScrollMethod<T> =>\n    (target, scrollOptions, config): void => {\n        const [element, scrollType]: [Element, \"Window\" | \"Element\"] = isWindow(target)\n            ? [scrollingElement(target.document.documentElement), \"Window\"]\n            : [target, \"Element\"];\n\n        const options = scrollOptions ?? {};\n\n        if (!isObject(options)) {\n            throw new TypeError(failedExecute(scrollName, scrollType));\n        }\n\n        if (!checkBehavior(options.behavior)) {\n            throw new TypeError(failedExecuteInvalidEnumValue(scrollName, scrollType, options.behavior));\n        }\n\n        if (scrollName === \"scrollBy\") {\n            options.left = nonFinite(options.left) + element.scrollLeft;\n            options.top = nonFinite(options.top) + element.scrollTop;\n        }\n\n        scrollWithOptions(element, options, config);\n    };\n\nexport const scroll = /* #__PURE__ */ createScroll(\"scroll\");\nexport const scrollTo = /* #__PURE__ */ createScroll(\"scrollTo\");\nexport const scrollBy = /* #__PURE__ */ createScroll(\"scrollBy\");\n\nexport const elementScroll = scroll as ScrollMethod<Element>;\nexport const elementScrollTo = scrollTo as ScrollMethod<Element>;\nexport const elementScrollBy = scrollBy as ScrollMethod<Element>;\n\nexport const windowScroll = scroll as ScrollMethod<typeof window>;\nexport const windowScrollTo = scrollTo as ScrollMethod<typeof window>;\nexport const windowScrollBy = scrollBy as ScrollMethod<typeof window>;\n", "/* eslint-disable no-bitwise */\nimport { checkBehavior, failedExecuteInvalidEnumValue, scrollingElement } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport { elementScroll } from \"./scroll.js\";\n\nconst enum ScrollAlignment {\n    ToEdgeIfNeeded,\n    CenterAlways,\n    LeftOrTop,\n    RightOrBottom,\n}\n\nconst enum WritingMode {\n    HorizontalTb,\n    VerticalRl,\n    VerticalLr,\n    SidewaysRl,\n    SidewaysLr,\n}\n\n// https://drafts.csswg.org/css-writing-modes-4/#block-flow\nconst normalizeWritingMode = (writingMode: string): WritingMode => {\n    switch (writingMode) {\n        case \"horizontal-tb\":\n        case \"lr\":\n        case \"lr-tb\":\n        case \"rl\":\n        case \"rl-tb\":\n            return WritingMode.HorizontalTb;\n\n        case \"vertical-rl\":\n        case \"tb\":\n        case \"tb-rl\":\n            return WritingMode.VerticalRl;\n\n        case \"vertical-lr\":\n        case \"tb-lr\":\n            return WritingMode.VerticalLr;\n\n        case \"sideways-rl\":\n            return WritingMode.SidewaysRl;\n\n        case \"sideways-lr\":\n            return WritingMode.SidewaysLr;\n    }\n\n    return WritingMode.HorizontalTb;\n};\n\ntype Tuple2<T> = [T, T];\n\nconst calcPhysicalAxis = <T>(writingMode: WritingMode, isLTR: boolean, hPos: T, vPos: T): [number, T, T] => {\n    /**  0b{vertical}{horizontal}  0: normal, 1: reverse */\n    let layout = 0b00;\n\n    const enum OP {\n        ReverseHorizontal = 0b01,\n        ReverseVertical = 0b10,\n    }\n\n    /**\n     * WritingMode.VerticalLr: ↓→\n     * | 1 | 4 |   |\n     * | 2 | 5 |   |\n     * | 3 |   |   |\n     *\n     * RTL: ↑→\n     * | 3 |   |   |\n     * | 2 | 5 |   |\n     * | 1 | 4 |   |\n     */\n    if (!isLTR) {\n        layout ^= OP.ReverseVertical;\n    }\n\n    switch (writingMode) {\n        /**\n         * ↓→\n         * | 1 | 2 | 3 |\n         * | 4 | 5 |   |\n         * |   |   |   |\n         *\n         * RTL: ↓←\n         * | 3 | 2 | 1 |\n         * |   | 5 | 4 |\n         * |   |   |   |\n         */\n        case WritingMode.HorizontalTb:\n            // swap horizontal and vertical\n            layout = (layout >> 1) | ((layout & 1) << 1);\n            [hPos, vPos] = [vPos, hPos];\n            break;\n\n        /**\n         * ↓←\n         * |   | 4 | 1 |\n         * |   | 5 | 2 |\n         * |   |   | 3 |\n         *\n         * RTL: ↑←\n         * |   |   | 3 |\n         * |   | 5 | 2 |\n         * |   | 4 | 1 |\n         */\n        case WritingMode.VerticalRl:\n        case WritingMode.SidewaysRl:\n            //  reverse horizontal\n            layout ^= OP.ReverseHorizontal;\n            break;\n\n        /**\n         * ↑→\n         * | 3 |   |   |\n         * | 2 | 5 |   |\n         * | 1 | 4 |   |\n         *\n         * RTL: ↓→\n         * | 1 | 4 |   |\n         * | 2 | 5 |   |\n         * | 3 |   |   |\n         */\n        case WritingMode.SidewaysLr:\n            // reverse vertical\n            layout ^= OP.ReverseVertical;\n            break;\n    }\n\n    return [layout, hPos, vPos];\n};\n\nconst isXReversed = (computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    const layout = calcPhysicalAxis(\n        normalizeWritingMode(computedStyle.writingMode),\n        computedStyle.direction !== \"rtl\",\n        undefined,\n        undefined,\n    )[0];\n    return (layout & 1) === 1;\n};\n\n// https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/dom/element.cc;l=1097-1189;drc=6a7533d4a1e9f2372223a9d912a9e53a6fa35ae0\nconst toPhysicalAlignment = (\n    options: Readonly<ScrollIntoViewOptions>,\n    writingMode: WritingMode,\n    isLTR: boolean,\n): Tuple2<ScrollAlignment> => {\n    const [layout, hPos, vPos] = calcPhysicalAxis(\n        writingMode,\n        isLTR,\n        options.block || \"start\",\n        options.inline || \"nearest\",\n    );\n\n    return [hPos, vPos].map((value, index) => {\n        switch (value) {\n            case \"center\":\n                return ScrollAlignment.CenterAlways;\n            case \"nearest\":\n                return ScrollAlignment.ToEdgeIfNeeded;\n\n            default: {\n                const reverse = (layout >> index) & 1;\n                return (value === \"start\") === !reverse ? ScrollAlignment.LeftOrTop : ScrollAlignment.RightOrBottom;\n            }\n        }\n    }) as Tuple2<ScrollAlignment>;\n};\n\n// code from stipsan/compute-scroll-into-view\n// https://github.com/stipsan/compute-scroll-into-view/blob/5396c6b78af5d0bbce11a7c4e93cc3146546fcd3/src/index.ts\n/**\n * Find out which edge to align against when logical scroll position is \"nearest\"\n * Interesting fact: \"nearest\" works similarily to \"if-needed\", if the element is fully visible it will not scroll it\n *\n * Legends:\n * ┌────────┐ ┏ ━ ━ ━ ┓\n * │ target │   frame\n * └────────┘ ┗ ━ ━ ━ ┛\n */\nconst mapNearest = (\n    align: ScrollAlignment,\n    scrollingEdgeStart: number,\n    scrollingEdgeEnd: number,\n    scrollingSize: number,\n    elementEdgeStart: number,\n    elementEdgeEnd: number,\n    elementSize: number,\n): Exclude<ScrollAlignment, ScrollAlignment.ToEdgeIfNeeded> | null => {\n    if (align !== ScrollAlignment.ToEdgeIfNeeded) {\n        return align;\n    }\n\n    /**\n     * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓\n     *          │  │\n     *        ┃ │  │ ┃        do nothing\n     *          │  │\n     *        ┗━│━━│━┛\n     *          └──┘\n     *\n     *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n     *\n     *    ┏ ━ ━ ━ ━ ┓\n     *   ┌───────────┐\n     *   │┃         ┃│        do nothing\n     *   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n        (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)\n    ) {\n        return null;\n    }\n\n    /**\n     * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n     *\n     *          ┌──┐\n     *        ┏━│━━│━┓         ┏━┌━━┐━┓\n     *          └──┘             │  │\n     *  from  ┃      ┃     to  ┃ └──┘ ┃\n     *\n     *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n     *\n     * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n     *                           │  │\n     *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n     *          │  │             │  │\n     *        ┗━│━━│━┛         ┗━│━━│━┛\n     *          │  │             └──┘\n     *          │  │\n     *          └──┘\n     *\n     * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───┐                 ┌───┐\n     *  │ ┃ │       ┃         ┃   │     ┃\n     *  └───┘                 └───┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n     *\n     *       from                 to\n     *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *        ┌───────────┐   ┌───────────┐\n     *    ┃   │     ┃     │   ┃         ┃ │\n     *        └───────────┘   └───────────┘\n     *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     */\n    if (\n        (elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n        (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)\n    ) {\n        return ScrollAlignment.LeftOrTop;\n    }\n\n    /**\n     * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n     *\n     *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n     *\n     *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n     *          ┌──┐             │  │\n     *        ┗━│━━│━┛         ┗━└━━┘━┛\n     *          └──┘\n     *\n     * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n     *\n     *          ┌──┐\n     *          │  │\n     *          │  │             ┌──┐\n     *        ┏━│━━│━┓         ┏━│━━│━┓\n     *          │  │             │  │\n     *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n     *                           │  │\n     *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n     *\n     * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *  ┌───────────┐           ┌───────────┐\n     *  │     ┃     │   ┃       │ ┃         ┃\n     *  └───────────┘           └───────────┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n     *\n     *           from                 to\n     *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n     *                ┌───┐             ┌───┐\n     *        ┃       │ ┃ │       ┃     │   ┃\n     *                └───┘             └───┘\n     *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n     *\n     */\n    if (\n        (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) ||\n        (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)\n    ) {\n        return ScrollAlignment.RightOrBottom;\n    }\n\n    return null;\n};\n\nconst canOverflow = (overflow: string | null): boolean => {\n    return overflow !== \"visible\" && overflow !== \"clip\";\n};\n\nconst getFrameElement = (element: Element): Element | null => {\n    try {\n        return element.ownerDocument.defaultView?.frameElement || null;\n    } catch {\n        return null;\n    }\n};\n\nconst isScrollable = (element: Element, computedStyle: Readonly<CSSStyleDeclaration>): boolean => {\n    if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n        return (\n            canOverflow(computedStyle.overflowY) ||\n            canOverflow(computedStyle.overflowX) ||\n            element === scrollingElement(element)\n        );\n    }\n\n    return false;\n};\n\nconst parentElement = (element: Element): Element | null => {\n    const pNode = element.parentNode;\n    const pElement = element.parentElement;\n\n    if (pElement === null && pNode !== null) {\n        if (pNode.nodeType === /** Node.DOCUMENT_FRAGMENT_NODE */ 11) {\n            return (pNode as ShadowRoot).host;\n        }\n        if (pNode.nodeType === /** Node.DOCUMENT_NODE */ 9) {\n            return getFrameElement(element);\n        }\n    }\n\n    return pElement;\n};\n\nconst clamp = (value: number, min: number, max: number): number => {\n    if (value < min) {\n        return min;\n    }\n\n    if (value > max) {\n        return max;\n    }\n\n    return value;\n};\n\nconst getSupportedScrollMarginProperty = (\n    ownerDocument: Document,\n): \"scroll-margin\" | \"scroll-snap-margin\" | undefined => {\n    // Webkit uses \"scroll-snap-margin\" https://bugs.webkit.org/show_bug.cgi?id=189265.\n    return ([\"scroll-margin\", \"scroll-snap-margin\"] as const).filter(\n        (property) => property in ownerDocument.documentElement.style,\n    )[0];\n};\n\nconst getElementScrollSnapArea = (\n    element: Element,\n    elementRect: Readonly<DOMRect>,\n    computedStyle: Readonly<CSSStyleDeclaration>,\n): [top: number, right: number, bottom: number, left: number] => {\n    const { top, right, bottom, left } = elementRect;\n    const scrollProperty = getSupportedScrollMarginProperty(element.ownerDocument);\n    if (!scrollProperty) {\n        return [top, right, bottom, left];\n    }\n\n    const scrollMarginValue = (edge: \"top\" | \"right\" | \"bottom\" | \"left\"): number => {\n        const value = computedStyle.getPropertyValue(`${scrollProperty}-${edge}`);\n        return parseInt(value, 10) || 0;\n    };\n\n    return [\n        top - scrollMarginValue(\"top\"),\n        right + scrollMarginValue(\"right\"),\n        bottom + scrollMarginValue(\"bottom\"),\n        left - scrollMarginValue(\"left\"),\n    ];\n};\n\nconst calcAlignEdge = (align: ScrollAlignment, start: number, end: number): number => {\n    switch (align) {\n        case ScrollAlignment.CenterAlways:\n            return (start + end) / 2;\n\n        case ScrollAlignment.RightOrBottom:\n            return end;\n\n        case ScrollAlignment.LeftOrTop:\n        case ScrollAlignment.ToEdgeIfNeeded:\n            return start;\n    }\n};\n\nconst getFrameViewport = (frame: Element, frameRect: Readonly<DOMRect>) => {\n    const visualViewport = frame.ownerDocument.defaultView?.visualViewport;\n    const [x, y, width, height] =\n        frame === scrollingElement(frame)\n            ? [0, 0, visualViewport?.width ?? frame.clientWidth, visualViewport?.height ?? frame.clientHeight]\n            : [frameRect.left, frameRect.top, frame.clientWidth, frame.clientHeight];\n\n    const left = x + frame.clientLeft;\n    const top = y + frame.clientTop;\n    const right = left + width;\n    const bottom = top + height;\n\n    return [top, right, bottom, left] as const;\n};\n\nconst computeScrollIntoView = (element: Element, options: ScrollIntoViewOptions): [Element, ScrollToOptions][] => {\n    // Collect all the scrolling boxes, as defined in the spec: https://drafts.csswg.org/cssom-view/#scrolling-box\n    const actions: [Element, ScrollToOptions][] = [];\n\n    let ownerDocument = element.ownerDocument;\n    let ownerWindow = ownerDocument.defaultView;\n\n    if (!ownerWindow) {\n        return actions;\n    }\n\n    const computedStyle = window.getComputedStyle(element);\n    const isLTR = computedStyle.direction !== \"rtl\";\n\n    const writingMode = normalizeWritingMode(\n        computedStyle.writingMode ||\n            computedStyle.getPropertyValue(\"-webkit-writing-mode\") ||\n            computedStyle.getPropertyValue(\"-ms-writing-mode\"),\n    );\n\n    const [alignH, alignV] = toPhysicalAlignment(options, writingMode, isLTR);\n\n    let [top, right, bottom, left] = getElementScrollSnapArea(element, element.getBoundingClientRect(), computedStyle);\n\n    for (let frame = parentElement(element); frame !== null; frame = parentElement(frame)) {\n        if (ownerDocument !== frame.ownerDocument) {\n            ownerDocument = frame.ownerDocument;\n            ownerWindow = ownerDocument.defaultView;\n            if (!ownerWindow) {\n                break;\n            }\n\n            const { left: dX, top: dY } = frame.getBoundingClientRect();\n            top += dY;\n            right += dX;\n            bottom += dY;\n            left += dX;\n        }\n\n        const frameStyle = ownerWindow.getComputedStyle(frame);\n\n        if (frameStyle.position === \"fixed\") {\n            break;\n        }\n\n        if (!isScrollable(frame, frameStyle)) {\n            continue;\n        }\n\n        const frameRect = frame.getBoundingClientRect();\n\n        const [frameTop, frameRight, frameBottom, frameLeft] = getFrameViewport(frame, frameRect);\n\n        const eAlignH = mapNearest(alignH, frameLeft, frameRight, frame.clientWidth, left, right, right - left);\n        const eAlignV = mapNearest(alignV, frameTop, frameBottom, frame.clientHeight, top, bottom, bottom - top);\n\n        const diffX =\n            eAlignH === null ? 0 : calcAlignEdge(eAlignH, left, right) - calcAlignEdge(eAlignH, frameLeft, frameRight);\n        const diffY =\n            eAlignV === null ? 0 : calcAlignEdge(eAlignV, top, bottom) - calcAlignEdge(eAlignV, frameTop, frameBottom);\n\n        const moveX = isXReversed(frameStyle)\n            ? clamp(diffX, -frame.scrollWidth + frame.clientWidth - frame.scrollLeft, -frame.scrollLeft)\n            : clamp(diffX, -frame.scrollLeft, frame.scrollWidth - frame.clientWidth - frame.scrollLeft);\n        const moveY = clamp(diffY, -frame.scrollTop, frame.scrollHeight - frame.clientHeight - frame.scrollTop);\n\n        actions.push([\n            frame,\n            { left: frame.scrollLeft + moveX, top: frame.scrollTop + moveY, behavior: options.behavior },\n        ]);\n\n        top = Math.max(top - moveY, frameTop);\n        right = Math.min(right - moveX, frameRight);\n        bottom = Math.min(bottom - moveY, frameBottom);\n        left = Math.max(left - moveX, frameLeft);\n    }\n\n    return actions;\n};\n\nexport const scrollIntoView = (\n    element: Element,\n    scrollIntoViewOptions?: ScrollIntoViewOptions,\n    config?: IScrollConfig,\n): void => {\n    const options = scrollIntoViewOptions || {};\n\n    if (!checkBehavior(options.behavior)) {\n        throw new TypeError(failedExecuteInvalidEnumValue(\"scrollIntoView\", \"Element\", options.behavior));\n    }\n\n    const actions = computeScrollIntoView(element, options);\n\n    actions.forEach(([frame, scrollToOptions]) => {\n        elementScroll(frame, scrollToOptions, config);\n    });\n};\n\nexport const elementScrollIntoView = scrollIntoView;\n", "import { backupMethod, isScrollBehaviorSupported, markPolyfill, modifyPrototypes } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport { scroll, scrollBy, scrollTo } from \"./scroll.js\";\n\ntype ScrollName = \"scroll\" | \"scrollTo\" | \"scrollBy\";\n\ntype Patch = <T extends ScrollName>(prop: T, func: (Element | typeof window)[T]) => void;\n\nconst createPolyfill =\n    (scrollName: ScrollName, patch: Patch) =>\n    (config?: IScrollConfig): void => {\n        if (isScrollBehaviorSupported(config)) {\n            return;\n        }\n\n        const scrollMethod = {\n            scroll,\n            scrollTo,\n            scrollBy,\n        }[scrollName];\n\n        patch(scrollName, function (this: Element | typeof window): void {\n            const args = arguments;\n            if (arguments.length === 1) {\n                scrollMethod(this, args[0] as ScrollToOptions, config);\n                return;\n            }\n\n            const left = args[0] as number;\n            const top = args[1] as number;\n            scrollMethod(this, { left, top });\n        });\n    };\n\nexport const elementScrollPolyfill = /* #__PURE__ */ createPolyfill(\"scroll\", modifyPrototypes);\nexport const elementScrollToPolyfill = /* #__PURE__ */ createPolyfill(\"scrollTo\", modifyPrototypes);\nexport const elementScrollByPolyfill = /* #__PURE__ */ createPolyfill(\"scrollBy\", modifyPrototypes);\n\nconst modifyWindow = <T extends \"scroll\" | \"scrollTo\" | \"scrollBy\">(prop: T, func: (typeof window)[T]): void => {\n    markPolyfill(func);\n    backupMethod(window, prop);\n    window[prop] = func;\n};\n\nexport const windowScrollPolyfill = /* #__PURE__ */ createPolyfill(\"scroll\", modifyWindow);\nexport const windowScrollToPolyfill = /* #__PURE__ */ createPolyfill(\"scrollTo\", modifyWindow);\nexport const windowScrollByPolyfill = /* #__PURE__ */ createPolyfill(\"scrollBy\", modifyWindow);\n", "import { backupMethod, isObject, isScrollBehaviorSupported, modifyPrototypes } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport { elementScrollIntoView } from \"./scrollIntoView.js\";\n\nfunction elementScrollIntoViewBoolean(this: Element, alignToTop?: unknown) {\n    elementScrollIntoView(this, {\n        block: alignToTop ?? true ? \"start\" : \"end\",\n        inline: \"nearest\",\n    });\n}\n\nexport const elementScrollIntoViewPolyfill = (config?: IScrollConfig): void => {\n    if (isScrollBehaviorSupported(config)) {\n        return;\n    }\n\n    const originalFunc = backupMethod(window.HTMLElement.prototype, \"scrollIntoView\", elementScrollIntoViewBoolean);\n\n    modifyPrototypes(\"scrollIntoView\", function scrollIntoView(this: Element): void {\n        const args = arguments;\n        const options = args[0] as unknown;\n\n        if (args.length === 1 && isObject(options)) {\n            elementScrollIntoView(this, options as ScrollIntoViewOptions, config);\n            return;\n        }\n\n        originalFunc.apply(this, args as never);\n    });\n};\n", "import { isScrollBehaviorSupported } from \"./common.js\";\nimport type { IScrollConfig } from \"./scroll-step.js\";\nimport {\n    elementScrollByPolyfill,\n    elementScrollPolyfill,\n    elementScrollToPolyfill,\n    windowScrollByPolyfill,\n    windowScrollPolyfill,\n    windowScrollToPolyfill,\n} from \"./scroll.polyfill.js\";\nimport { elementScrollIntoViewPolyfill } from \"./scrollIntoView.polyfill.js\";\n\nexport * from \"./scroll.polyfill.js\";\nexport * from \"./scrollIntoView.polyfill.js\";\n\nexport const polyfill = (config?: IScrollConfig): void => {\n    if (isScrollBehaviorSupported(config)) {\n        return;\n    }\n\n    elementScrollPolyfill(config);\n    elementScrollToPolyfill(config);\n    elementScrollByPolyfill(config);\n    elementScrollIntoViewPolyfill(config);\n\n    windowScrollPolyfill(config);\n    windowScrollToPolyfill(config);\n    windowScrollByPolyfill(config);\n};\n"],
  "mappings": "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",
  "names": ["scrollIntoView"]
}
